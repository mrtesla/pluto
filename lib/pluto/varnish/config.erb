
<% @backends.each do |name, levels| %>
<% levels.each_with_index do |hosts, level| %>
director <%= name %>__<%= level %> round-robin {
  <% hosts.each do |(host, port)| %>
  {
    .backend = {
      .host = "<%= (host == 'localhost' ? '127.0.0.1' : host) %>";
      .port = "<%= port %>";
    }
  }
  <% end %>
}
<% end %>
<% end %>

<% if @fallback %>
backend fallback_host {
  .host = "<%= @fallback[0] %>";
  .port = "<%= @fallback[1] %>";
}
<% end %>


acl purge {
  "localhost";
}


sub vcl_recv {
  if (req.request == "PURGE") {
    if (!client.ip ~ purge) {
      error 405 "Not allowed.";
    }
    return (lookup);
  }

  if (req.http.host ~ "^not_a_host$") {
    error 404 "Unknown virtual host";

  <% @frontends.each do |appl, hostnames| %>
  <% hostnames.each do |hostname| %>
  } elsif (req.http.host ~ "^(www.)?<%= hostname %>([:]\d+)?$" &&
           req.url ~ "^/") {
    set req.http.host             = "<%= hostname %>";
    set req.http.X-Forward-Prefix = "/";

    if (req.restarts == 0) {
      if (req.request == "GET" || req.request == "HEAD") {
        set req.http.X-Pluto-Cascade = "0";
      } else { # skip secondary backends for Non GET/HEAD requests
        set req.http.X-Pluto-Cascade = "<%= @backends[appl].size - 1 %>";
      }
      set req.http.X-Pluto-Max-Cascade = "<%= @backends[appl].size - 1 %>";
    }

    if (req.http.X-Pluto-Pass) {
      remove req.http.X-Pluto-Pass;
      if (req.http.X-Pluto-Cascade == "none") {
      <% @backends[appl].each_with_index do |_, level| %>
      } elsif (req.http.X-Pluto-Cascade == "<%= level %>") {
        set req.http.X-Pluto-Cascade = "<%= level + 1 %>";
      <% end %>
      }
    }

    if (req.http.X-Pluto-Cascade == "none") {
    <% @backends[appl].each_with_index do |_, level| %>
    } elsif (req.http.X-Pluto-Cascade == "<%= level %>") {
      set req.backend = <%= appl %>__<%= level %>;
    <% end %>
    }
  <% end %>
  <% end %>

  <% if @fallback %>
  } else {
    set req.backend = fallback_host;
  <% end %>

  }

  if (req.restarts == 0) {
    if (req.http.x-forwarded-for) {
      set req.http.X-Forwarded-For =
          req.http.X-Forwarded-For + ", " + client.ip;
    } else {
      set req.http.X-Forwarded-For = client.ip;
    }
  }

  if (req.http.Accept-Encoding) {
    if (req.url ~ "\.(jpg|png|gif|gz|tgz|bz2|tbz|mp3|ogg)(\?\d+)?$") {
      # No point in compressing these
      remove req.http.Accept-Encoding;
    } elsif (req.http.Accept-Encoding ~ "gzip") {
      set req.http.Accept-Encoding = "gzip";
    } elsif (req.http.Accept-Encoding ~ "deflate") {
      set req.http.Accept-Encoding = "deflate";
    } else {
      # unkown algorithm
      remove req.http.Accept-Encoding;
    }
  }

  if (req.request != "GET"     &&
      req.request != "HEAD"    &&
      req.request != "PUT"     &&
      req.request != "POST"    &&
      req.request != "TRACE"   &&
      req.request != "OPTIONS" &&
      req.request != "DELETE") {
    /* Non-RFC2616 or CONNECT which is weird. */
    return (pipe);
  }

  if (req.http.upgrade ~ "(?i)websocket") {
    return (pipe);
  }

  if (req.request != "GET" && req.request != "HEAD") {
    /* We only deal with GET and HEAD by default */
    return (pass);
  }

  if (req.url ~ "^/lalala") {
    /* Not cacheable by default */
    return (pass);
  }

  if (req.http.Cookie) {
    set req.http.Cookie = regsuball(req.http.Cookie, "__utm.=[^;]+(; )?", "");
    if (req.http.Cookie ~ "^ *$") {
        remove req.http.Cookie;
    }
  }

  if (req.request == "GET" && req.url ~ "\.(css|js|gif|jpg|jpeg|bmp|png|ico|img|tga|wmf)(\?\d+)?$") {
    remove req.http.Cookie;
    return(lookup);
  }

  if (req.http.Authorization || req.http.Cookie) {
    /* Not cacheable by default */
    return (pass);
  }

  return(lookup);
}

sub vcl_pipe {
  if (req.http.upgrade) {
    set bereq.http.upgrade = req.http.upgrade;
  }

  # Note that only the first request to the backend will have
  # X-Forwarded-For set.  If you use X-Forwarded-For and want to
  # have it set for all requests, make sure to have:
  # set bereq.http.connection = "close";
  # here.  It is not set by default as it might break some broken web
  # applications, like IIS with NTLM authentication.
  return (pipe);
}

sub vcl_pass {
  return (pass);
}

sub vcl_hash {
  hash_data(req.url);

  if (req.http.host) {
    hash_data(req.http.host);
  } else {
    hash_data(server.ip);
  }

  return (hash);
}

sub vcl_hit {
  if (req.request == "PURGE") {
    purge;
    error 200 "Purged. (HIT)";
  }

  if (req.http.Cache-Control ~ "no-cache") {
    # Ignore requests via proxy caches,  IE users and badly behaved crawlers
    # like msnbot that send no-cache with every request.
    if (! (req.http.Via || req.http.User-Agent ~ "bot|MSIE")) {
      set obj.ttl = 0s;
      return (restart);
    }
  }

  return (deliver);
}

sub vcl_miss {
  if (req.request == "PURGE") {
    purge;
    error 200 "Purged. (MISS)";
  }

  return (fetch);
}

sub vcl_fetch {
  if (req.http.X-Pluto-Max-Cascade){
    if ((beresp.status == 404) && (req.http.X-Pluto-Cascade != req.http.X-Pluto-Max-Cascade)) {
      set req.http.X-Pluto-Pass = "true";
      return (restart);
    }
  }

  unset beresp.http.Server;
  set beresp.http.Server = "Mr. Server";

  if (beresp.http.Content-Type ~ "^text\/" ||
      beresp.http.Content-Type ~ "^application\/json" ||
      req.url                  ~ "\.(css|js)(\?\d+)?$") {
    set beresp.do_gzip = true;
    # this should only happen for non authenticated URI's

    if (!(req.url ~ "^/lalala" || beresp.http.Set-Cookie)) {
      set beresp.http.Cache-Control = "max-age=600,public";
    }
  }

  if (beresp.http.Content-Type ~ "^text\/html") {
    set beresp.do_esi = true;
  }

  if (req.url ~ "^/lalala") {
    return (deliver);
  }

  if (req.url ~ "\.(css|js|gif|jpg|jpeg|bmp|png|ico|img|tga|wmf)(\?\d+)?$") {
    unset beresp.http.Set-Cookie;
    set beresp.http.Cache-Control = "max-age=31536000,public";

    if (beresp.ttl < 3600s) {
      set beresp.ttl = 3600s;
    }
  }

  if (beresp.ttl <= 0s ||
      beresp.http.Set-Cookie ||
      beresp.http.Vary == "*") {
    /*
     * Mark as "Hit-For-Pass" for the next 2 minutes
     */
    set beresp.ttl = 120s;
    return (hit_for_pass);
  }

  return (deliver);
}

sub vcl_deliver {
  if (obj.hits > 0) {
    set resp.http.X-Cache = "HIT";
  } else {
    set resp.http.X-Cache = "MISS";
  }

  remove resp.http.X-Powered-By;
  remove resp.http.X-Varnish;
  remove resp.http.Via;

  return (deliver);
}
